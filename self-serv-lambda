"use strict";

/**
 * AWS Lambda (CommonJS) - DynamoDB toggle + read (invoked from Amazon Connect contact flow)
 *
 * Env vars:
 *   TABLE_NAME  (optional, default: hmsa-connect-selfsvc)
 *
 * Expected input (Connect):
 *   event.Details.Parameters.DeptID
 *   event.Details.Parameters.function
 * OR
 *   event.Details.ContactData.Attributes.DeptID
 *   event.Details.ContactData.Attributes.function
 *
 * Function values:
 *   setMotdTrue | setMotdFalse | setMtgTrue | setMtgFalse | returnValues
 *
 * Behavior:
 *  - If item for DeptID does NOT exist => ok:false error (for BOTH reads and updates)
 *  - returnValues => returns flat json with values in table (DeptID, PIN, LastModified, motd, mtg)
 */

const {
  DynamoDBClient,
  GetItemCommand,
  UpdateItemCommand,
} = require("@aws-sdk/client-dynamodb");

const TABLE_NAME = process.env.TABLE_NAME || "hmsa-connect-selfsvc";
const ddb = new DynamoDBClient({});

function parseDeptId(raw) {
  if (raw === undefined || raw === null) throw new Error("DeptID is required");
  const n = Number(raw);
  if (!Number.isFinite(n) || n <= 0) throw new Error("DeptID must be a positive number");
  return String(Math.trunc(n)); // DynamoDB N is a string
}

function flattenDdbItem(item) {
  if (!item) return null;

  const out = {};
  if (item.DeptID?.N != null) out.DeptID = Number(item.DeptID.N);
  if (item.PIN?.N != null) out.PIN = Number(item.PIN.N);
  if (item.LastModified?.S != null) out.LastModified = item.LastModified.S;

  if (item.motd?.BOOL != null) out.motd = item.motd.BOOL;
  if (item.mtg?.BOOL != null) out.mtg = item.mtg.BOOL;

  return out;
}

function getConnectParams(event) {
  const details = event?.Details || {};
  const params = details?.Parameters || {};
  const attrs = details?.ContactData?.Attributes || {};

  // Prefer Lambda block Parameters, then Contact Attributes, then top-level (for testing)
  const DeptID = params.DeptID ?? attrs.DeptID ?? event?.DeptID;
  const fn = params.function ?? attrs.function ?? event?.function;

  return { DeptID, fn };
}

async function getValues({ deptIdN }) {
  const resp = await ddb.send(
    new GetItemCommand({
      TableName: TABLE_NAME,
      Key: { DeptID: { N: deptIdN } },
      ConsistentRead: true,
    })
  );

  if (!resp.Item) {
    const deptNum = Number(deptIdN);
    const err = new Error(`No item found for DeptID=${deptNum}`);
    err.code = "NOT_FOUND";
    throw err;
  }

  return flattenDdbItem(resp.Item);
}

async function setFlag({ deptIdN, flagName, flagValue }) {
  const nowIso = new Date().toISOString();

  try {
    const resp = await ddb.send(
      new UpdateItemCommand({
        TableName: TABLE_NAME,
        Key: { DeptID: { N: deptIdN } },

        // Do NOT create new items; require existing key
        ConditionExpression: "attribute_exists(DeptID)",

        UpdateExpression: "SET #flag = :v, #lm = :lm",
        ExpressionAttributeNames: {
          "#flag": flagName,
          "#lm": "LastModified",
        },
        ExpressionAttributeValues: {
          ":v": { BOOL: !!flagValue },
          ":lm": { S: nowIso },
        },
        ReturnValues: "ALL_NEW",
      })
    );

    return flattenDdbItem(resp.Attributes);
  } catch (e) {
    if (e && (e.name === "ConditionalCheckFailedException" || e.Code === "ConditionalCheckFailedException")) {
      const deptNum = Number(deptIdN);
      const err = new Error(`No item found for DeptID=${deptNum}`);
      err.code = "NOT_FOUND";
      throw err;
    }
    throw e;
  }
}

exports.handler = async (event) => {
  try {
    console.log("Incoming event:", JSON.stringify(event, null, 2));

    const { DeptID, fn } = getConnectParams(event);

    const deptIdN = parseDeptId(DeptID);
    const functionName = String(fn || "").trim();
    if (!functionName) throw new Error("function is required");

    const allowed = new Set([
      "setMotdTrue",
      "setMotdFalse",
      "setMtgTrue",
      "setMtgFalse",
      "returnValues",
    ]);

    if (!allowed.has(functionName)) {
      throw new Error(
        `Invalid function '${functionName}'. Allowed: ${Array.from(allowed).join(", ")}`
      );
    }

    let values;

    switch (functionName) {
      case "returnValues":
        values = await getValues({ deptIdN });
        return {
          ok: true,
          tableName: TABLE_NAME,
          ...values,
        };

      case "setMotdTrue":
        values = await setFlag({ deptIdN, flagName: "motd", flagValue: true });
        break;
      case "setMotdFalse":
        values = await setFlag({ deptIdN, flagName: "motd", flagValue: false });
        break;
      case "setMtgTrue":
        values = await setFlag({ deptIdN, flagName: "mtg", flagValue: true });
        break;
      case "setMtgFalse":
        values = await setFlag({ deptIdN, flagName: "mtg", flagValue: false });
        break;

      default:
        throw new Error("Unhandled function");
    }

    return {
      ok: true,
      tableName: TABLE_NAME,
      ...values,
    };
  } catch (err) {
    const errMsg = err?.message || "Unknown error";
    const errCode = err?.code || err?.name || "ERROR";

    console.error("ERROR", {
      msg: errMsg,
      code: errCode,
      stack: err?.stack,
      tableName: TABLE_NAME,
    });

    return {
      ok: false,
      tableName: TABLE_NAME,
      error: errMsg,
      code: errCode,
    };
  }
};
